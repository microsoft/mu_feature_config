# @ VariableList_test.py
#
# Copyright (c) 2022, Microsoft Corporation. All rights reserved.<BR>
# SPDX-License-Identifier: BSD-2-Clause-Patent
#
#

import unittest
import pytest
from xml.dom.minidom import parseString

from VariableList import Schema, ParseError, InvalidNameError, InvalidRangeError


class SchemaParseUnitTests(unittest.TestCase):
    schemaTemplate = """<ConfigSchema xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:noNamespaceSchemaLocation="configschema.xsd">

  <Enums>
    <Enum name="e_continuous_t">
        <Value name="v_0" value="0" />
        <Value name="v_1" value="1" />
        <Value name="v_2" value="2" />
    </Enum>

    <Enum name="e_discontinuous_t" default="v_2" >
        <Value name="v_0" value="0" />
        <!-- 1 intentionally skipped -->
        <Value name="v_2" value="2" />
    </Enum>

    <Enum name="e_nozero_t" >
        <!-- 0 intentionally skipped -->
        <Value name="v_1" value="1" />
        <Value name="v_2" value="2" />
    </Enum>

    <Enum name="e_padding_overlap_t">
        <Value name="v_0" value="0" />
        <Value name="v_1" value="1" />
        <Value name="v_padding" value="0xffffffff" /> <!-- overlaps with the autogenerated padding value-->
    </Enum>

    <Enum name="e_negative_t">
        <Value name="v_0" value="0" />
        <Value name="v_1" value="1" />
        <Value name="v_n1" value="-1" />
    </Enum>
  </Enums>

  <Structs>
    <Struct name="s_limits_t">
        <Member name="m_uint8_t" type="uint8_t" />
        <Member name="m_uint8_t_d10" type="uint8_t" default="10" />
        <Member name="m_uint8_t_d10_min5" type="uint8_t" default="10" min="5" />
        <Member name="m_uint8_t_d10_max20" type="uint8_t" default="10" max="20" />
        <Member name="m_e_continuous_t" type="e_continuous_t" />
        <Member name="m_e_continuous_t_dv_1" type="e_continuous_t" default="v_1" />
    </Struct>

    <Struct name="s_simple_t">
        <Member name="m_uint32_t_d1_max10" type="uint32_t" default="1" max="10" />
        <Member name="m_uint32_t_d2_max10" type="uint32_t" default="2" max="10" />
    </Struct>

    <Struct name="s_array_t">
        <Member name="m_uint8_t_c5_max10" type="uint8_t" count="5" default="{1,2,3,4,5}" max="{10}" />
    </Struct>

    <Struct name="s_array_structs_t">
        <Member name="m_s_simple_t_c5" type="s_simple_t" count="5" />
    </Struct>

  </Structs>

  <Knobs namespace="{FE3ED49F-B173-41ED-9076-356661D46A42}">
    <!-- primitive knobs -->
    <Knob type="uint8_t" name="k_uint8_t"  />
    <Knob type="uint8_t" name="k_uint8_t_d10"  default="10" />
    <Knob type="uint8_t" name="k_uint8_t_d10_min5"  default="10" min="5" />
    <Knob type="uint8_t" name="k_uint8_t_d10_max20"  default="10" max="20" />
    <Knob type="uint8_t" name="k_uint8_t_d10_min5_max20"  default="10" min="5" max="20" />

    <Knob type="int8_t" name="k_int8_t" />
    <Knob type="int8_t" name="k_int8_t_d10" default="10" />
    <Knob type="int8_t" name="k_int8_t_dn10" default="-10" />
    <Knob type="int8_t" name="k_int8_t_d10_minn5" min="-5" default="10" />
    <Knob type="int8_t" name="k_int8_t_d10_max20" max="20" default="10" />
    <Knob type="int8_t" name="k_int8_t_d10_minn5_max20" min="-5" max="20" default="10" />

    <Knob type="uint16_t" name="k_uint16_t" />
    <Knob type="uint16_t" name="k_uint16_t_d1000" default="1000" />
    <Knob type="uint16_t" name="k_uint16_t_d1000_min500" default="1000" min="500" />
    <Knob type="uint16_t" name="k_uint16_t_d1000_max2000" default="1000" max="2000" />
    <Knob type="uint16_t" name="k_uint16_t_d1000_min500_max2000" default="1000" min="500" max="2000" />

    <Knob type="int16_t" name="k_int16_t" />
    <Knob type="int16_t" name="k_int16_t_d1000" default="1000" />
    <Knob type="int16_t" name="k_int16_t_dn1000" default="-1000" />
    <Knob type="int16_t" name="k_int16_t_d1000_minn500" default="1000" min="-500" />
    <Knob type="int16_t" name="k_int16_t_d1000_max2000" default="1000" max="2000" />
    <Knob type="int16_t" name="k_int16_t_d1000_minn500_max2000" default="1000" min="-500" max="2000" />
    
    <Knob type="uint32_t" name="k_uint32_t" />
    <Knob type="uint32_t" name="k_uint32_t_d1000000" default="1000000" />
    <Knob type="uint32_t" name="k_uint32_t_d1000000_min500000" default="1000000" min="500000" />
    <Knob type="uint32_t" name="k_uint32_t_d1000000_max2000000" default="1000000" max="2000000" />
    <Knob type="uint32_t" name="k_uint32_t_d1000000_min500000_max2000000" default="1000000" min="500000" max="2000000" />
    
    <Knob type="int32_t" name="k_int32_t" />
    <Knob type="int32_t" name="k_int32_t_d1000000" default="1000000" />
    <Knob type="int32_t" name="k_int32_t_dn1000000" default="-1000000" />
    <Knob type="int32_t" name="k_int32_t_d1000000_minn500000" default="1000000" min="-500000"/>
    <Knob type="int32_t" name="k_int32_t_d1000000_max2000000" default="1000000" max="2000000"/>
    <Knob type="int32_t" name="k_int32_t_d1000000_minn500000_max2000000" default="1000000" min="-500000" max="2000000"/>

    <Knob type="uint64_t" name="k_uint64_t" />
    <Knob type="uint64_t" name="k_uint64_t_d10000000000" default="10000000000" />
    <Knob type="uint64_t" name="k_uint64_t_d10000000000_min5000000000" default="10000000000" min="5000000000" />
    <Knob type="uint64_t" name="k_uint64_t_d10000000000_max20000000000" default="10000000000" max="20000000000" />
    <Knob type="uint64_t" name="k_uint64_t_d10000000000_min5000000000_max20000000000" default="10000000000" min="5000000000" max="20000000000" />
    
    <Knob type="int64_t" name="k_int64_t" />
    <Knob type="int64_t" name="k_int64_t_d10000000000" default="10000000000" />
    <Knob type="int64_t" name="k_int64_t_dn10000000000" default="-10000000000" />
    <Knob type="int64_t" name="k_int64_t_d10000000000_minn5000000000" default="10000000000" min="-5000000000" />
    <Knob type="int64_t" name="k_int64_t_d10000000000_max20000000000" default="10000000000" max="20000000000" />
    <Knob type="int64_t" name="k_int64_t_d10000000000_minn500000000_max20000000000" default="10000000000" min="-5000000000" max="20000000000" />

    <Knob type="float" name="k_float" />
    <Knob type="float" name="k_float_d10_5" default="10.5" />
    <Knob type="float" name="k_float_dn10_5" default="-10.5" />
    <Knob type="float" name="k_float_d10_5_minn5_5" default="10.5" min="-5.5" />
    <Knob type="float" name="k_float_d10_5_max20_5" default="10.5" max="20.5" />
    <Knob type="float" name="k_float_d10_5_minn5_5_max20_5" default="10.5" min="-5.5" max="20.5" />

    <Knob type="double" name="k_double" />
    <Knob type="double" name="k_double_d10_000005" default="10.000005" />
    <Knob type="double" name="k_double_dn10_000005" default="-10.000005" />
    <Knob type="double" name="k_double_d10_5_minn5_5" default="10.5" min="-5.5" />
    <Knob type="double" name="k_double_d10_5_max20_5" default="10.5" max="20.5" />
    <Knob type="double" name="k_double_d10_5_minn5_5_max20_5" default="10.5" min="-5.5" max="20.5" />

    <Knob type="bool" name="k_bool" />
    <Knob type="bool" name="k_bool_d1" default="true" />

    <!-- Enum knobs -->

    <Knob type="e_continuous_t" name="k_e_continuous_t" />
    <Knob type="e_continuous_t" name="k_e_continuous_t_dv_2" default="v_2" />
    
    <Knob type="e_discontinuous_t" name="k_e_discontinuous_t" />
    <Knob type="e_discontinuous_t" name="k_e_discontinuous_t_dv_0" default="v_0" />

    <Knob type="e_nozero_t" name="k_e_nozero_t" />
    <Knob type="e_nozero_t" name="k_e_nozero_t_dv_2" default="v_2" />

    <Knob type="e_padding_overlap_t" name="k_e_padding_overlap_t" />

    <!-- Struct knobs -->
    <Knob type="s_limits_t" name="k_s_limits_t" />
    <Knob type="s_limits_t" name="k_s_limits_t_d1_2_5_6_v_1_v_2" default="{1,2,5,6,v_1,v_2}" />
    
    <!-- This knob overrides the minimums to values that are more restrictive than
         the s_limits_t type-->
    <Knob type="s_limits_t" name="k_s_limits_t_min" min="{0,10,10,10,,}" />

    <Knob type="s_array_t" name="k_s_array_t" />
    <Knob type="s_array_t" name="k_s_array_t_d6_7_8_9_10" default="{{6,7,8,9,10}}"/>
    <Knob type="s_array_t" name="k_s_array_t_d5" default="{{5}}"/>

    <Knob type="s_array_structs_t" name="k_s_array_structs_t" />

  </Knobs>

</ConfigSchema>""" # noqa

    # Generates a dom with an xml snippet added to the template
    # This helper is used by tests to inject extra snippets in to the base
    # test xml (which may or may not be invalid)
    def insert_xml(self, xml):
        # Parse the template
        dom = parseString(self.schemaTemplate)
        # Parse the snippet to insert
        insert_dom = parseString(xml)
        # Import the first (only) element of the snippet
        n = dom.importNode(insert_dom.childNodes[0], deep=True)
        # Insert it as a child of the root element of the template
        dom.childNodes[0].appendChild(n)
        return dom

    # Test the basic template (which should have no errors)
    def test_golden(self):
        Schema.parse(self.schemaTemplate)
        pass

    def test_missing_enum_value(self):
        dom = self.insert_xml("""
<Enums>
    <Enum name="MISSING_VALUE" help="Enum with missing values">
      <Value name="ELEMENT1" value="0" help="First mode" />
      <Value name="ELEMENT2"           help="Second mode" />
      <Value name="ELEMENT3" value="2" help="Third mode" />
    </Enum>
</Enums>""")
        self.assertRaises(ParseError, Schema, dom)

    def test_invalid_enum_value(self):
        dom = self.insert_xml("""
<Enums>
    <Enum name="INVALID_VALUE" help="Enum with invalid values">
      <Value name="ELEMENT1" value="x" help="First mode" />
    </Enum>
</Enums>""")
        self.assertRaises(ParseError, Schema, dom)

    def test_invalid_enum_value_name(self):
        dom = self.insert_xml("""
<Enums>
    <Enum name="INVALID_VALUE_NAME" help="Enum with invalid values">
      <Value name="1ELEMENT1" value="0" help="First mode" />
    </Enum>
</Enums>""")
        self.assertRaises(InvalidNameError, Schema, dom)

    def test_invalid_enum_name(self):
        dom = self.insert_xml("""
<Enums>
    <Enum name="1INVALID_NAME" help="Enum with invalid values">
      <Value name="ELEMENT1" value="0" help="First mode" />
    </Enum>
</Enums>""")
        self.assertRaises(InvalidNameError, Schema, dom)

    # Validates
    #    1. The default value of a a knob is correct
    #    2. Modifying a subknob impacts the value of the subknob
    #    3. The value impacts the value of the knob and doesn't effect the default
    def test_default_get_set(self):
        schema = Schema.parse(self.schemaTemplate)

        knob = schema.get_knob("k_s_array_t")

        # The initial value will be None
        self.assertEqual(knob.value, None)
        # The default value should be valid
        self.assertEqual(knob.default['m_uint8_t_c5_max10'], [1, 2, 3, 4, 5])

        # Get the a subknob and modify a single element
        subknob = schema.get_knob("k_s_array_t.m_uint8_t_c5_max10[1]")
        subknob.value = 10
        self.assertEqual(subknob.value, 10)

        # The value will now be initialized from default,
        # with the single value modified
        self.assertEqual(knob.value['m_uint8_t_c5_max10'], [1, 10, 3, 4, 5])
        # Verify the default hasn't changed
        self.assertEqual(knob.default['m_uint8_t_c5_max10'], [1, 2, 3, 4, 5])

    def validate_min_bound(self, schema, knob_name, default, limit):
        schema.get_knob(knob_name).value = default  # Set to a good value
        self.assertEqual(schema.get_knob(knob_name).value, default)  # Verify it is set
        schema.get_knob(knob_name).value = limit  # Try setting to the limit
        self.assertEqual(schema.get_knob(knob_name).value, limit)  # Verify it is set
        with pytest.raises(InvalidRangeError):
            schema.get_knob(knob_name).value = limit - 1  # Try setting beyond the limit
        self.assertEqual(schema.get_knob(knob_name).value, limit)  # Verify it had no effect

    def validate_max_bound(self, schema, knob_name, default, limit):
        schema.get_knob(knob_name).value = default  # Set to a good value
        self.assertEqual(schema.get_knob(knob_name).value, default)  # Verify it is set
        schema.get_knob(knob_name).value = limit  # Try setting to the limit
        self.assertEqual(schema.get_knob(knob_name).value, limit)  # Verify it is set
        with pytest.raises(InvalidRangeError):
            schema.get_knob(knob_name).value = limit + 1  # Try setting beyond the limit
        self.assertEqual(schema.get_knob(knob_name).value, limit)  # Verify it had no effect

    def test_basic_ranges(self):
        schema = Schema.parse(self.schemaTemplate)

        self.validate_min_bound(schema, "k_uint8_t_d10_min5_max20", 10, 5)
        self.validate_max_bound(schema, "k_uint8_t_d10_min5_max20", 10, 20)
        self.validate_min_bound(schema, "k_int8_t_d10_minn5_max20", 10, -5)
        self.validate_max_bound(schema, "k_int8_t_d10_minn5_max20", 10, 20)
        self.validate_min_bound(schema, "k_uint16_t_d1000_min500_max2000", 1000, 500)
        self.validate_max_bound(schema, "k_uint16_t_d1000_min500_max2000", 1000, 2000)
        self.validate_min_bound(schema, "k_int16_t_d1000_minn500_max2000", 1000, -500)
        self.validate_max_bound(schema, "k_int16_t_d1000_minn500_max2000", 1000, 2000)
        self.validate_min_bound(schema, "k_uint32_t_d1000000_min500000_max2000000", 1000000, 500000)
        self.validate_max_bound(schema, "k_uint32_t_d1000000_min500000_max2000000", 1000000, 2000000)
        self.validate_min_bound(schema, "k_int32_t_d1000000_minn500000_max2000000", 1000000, -500000)
        self.validate_max_bound(schema, "k_int32_t_d1000000_minn500000_max2000000", 1000000, 2000000)
        self.validate_min_bound(schema, "k_uint64_t_d10000000000_min5000000000_max20000000000", 10000000000, 5000000000)
        self.validate_max_bound(schema, "k_uint64_t_d10000000000_min5000000000_max20000000000", 10000000000, 20000000000)  # noqa: E501
        self.validate_min_bound(schema, "k_int64_t_d10000000000_minn500000000_max20000000000", 10000000000, -5000000000)
        self.validate_max_bound(schema, "k_int64_t_d10000000000_minn500000000_max20000000000", 10000000000, 20000000000)
        self.validate_min_bound(schema, "k_float_d10_5_minn5_5_max20_5", 10.5, -5.5)
        self.validate_max_bound(schema, "k_float_d10_5_minn5_5_max20_5", 10.5, 20.5)
        self.validate_min_bound(schema, "k_double_d10_5_minn5_5_max20_5", 10.5, -5.5)
        self.validate_max_bound(schema, "k_double_d10_5_minn5_5_max20_5", 10.5, 20.5)

    def test_enum_ranges(self):
        schema = Schema.parse(self.schemaTemplate)

        schema.get_knob("k_e_continuous_t").value = 0  # Set a valid value
        self.assertEqual(schema.get_knob("k_e_continuous_t").value, 0)  # Verify it applied
        schema.get_knob("k_e_continuous_t").value = 1  # Set a valid value
        self.assertEqual(schema.get_knob("k_e_continuous_t").value, 1)  # Verify it applied
        schema.get_knob("k_e_continuous_t").value = 2  # Set a valid value
        self.assertEqual(schema.get_knob("k_e_continuous_t").value, 2)  # Verify it applied
        with pytest.raises(InvalidRangeError):
            schema.get_knob("k_e_continuous_t").value = 3  # Set an invalid
        self.assertEqual(schema.get_knob("k_e_continuous_t").value, 2)  # Verify it didn't have an effect

        schema.get_knob("k_e_discontinuous_t").value = 0  # Set a valid value
        self.assertEqual(schema.get_knob("k_e_discontinuous_t").value, 0)  # Verify it applied
        schema.get_knob("k_e_discontinuous_t").value = 2  # Set a valid value
        self.assertEqual(schema.get_knob("k_e_discontinuous_t").value, 2)  # Verify it applied
        with pytest.raises(InvalidRangeError):
            schema.get_knob("k_e_discontinuous_t").value = 1  # Set an invalid
        self.assertEqual(schema.get_knob("k_e_discontinuous_t").value, 2)  # Verify it didn't have an effect

    def test_array_ranges(self):
        schema = Schema.parse(self.schemaTemplate)

        knob = schema.get_knob("k_s_array_t")

        # The initial value will be None
        self.assertEqual(knob.value, None)
        # The default value should be valid
        self.assertEqual(knob.default['m_uint8_t_c5_max10'], [1, 2, 3, 4, 5])

        # Get the a subknob and modify a single element
        subknob = schema.get_knob("k_s_array_t.m_uint8_t_c5_max10[1]")
        subknob.value = 10
        self.assertEqual(subknob.value, 10)
        with pytest.raises(InvalidRangeError):
            subknob.value = 20  # Try setting a value out of range
        self.assertEqual(subknob.value, 10)  # Verify there was no effect

    def test_array_shorthand(self):
        # Verify that arrays specified with the single element shorthand
        # have their elements initialized correctly
        # (multi-element arrays can be written as a single element, and it is
        #  implicit that that element be used for all elements of the array)
        schema = Schema.parse(self.schemaTemplate)

        knob = schema.get_knob("k_s_array_t_d5")

        # The initial value will be None
        self.assertEqual(knob.value, None)
        # The default value should be valid
        self.assertEqual(knob.default['m_uint8_t_c5_max10'], [5, 5, 5, 5, 5])

    def test_struct_ranges(self):
        schema = Schema.parse(self.schemaTemplate)

        knob = schema.get_knob("k_s_limits_t")

        # The initial value will be None
        self.assertEqual(knob.value, None)
        # The default value should be valid
        self.assertEqual(knob.default['m_uint8_t'], 0)
        self.assertEqual(knob.default['m_uint8_t_d10'], 10)
        self.assertEqual(knob.default['m_uint8_t_d10_min5'], 10)
        self.assertEqual(knob.default['m_uint8_t_d10_max20'], 10)
        self.assertEqual(knob.default['m_e_continuous_t'], 0)
        self.assertEqual(knob.default['m_e_continuous_t_dv_1'], 1)

        # Get the a subknob and modify a single element
        subknob = schema.get_knob("k_s_limits_t.m_uint8_t_d10_min5")
        subknob.value = 5
        self.assertEqual(subknob.value, 5)
        with pytest.raises(InvalidRangeError):
            subknob.value = 4  # Try setting a value out of range
        self.assertEqual(subknob.value, 5)  # Verify there was no effect

    def test_default_out_of_range_knob(self):
        dom = self.insert_xml("""
<Knobs namespace="{FE3ED49F-B173-41ED-9076-356661D46A42}">
    <Knob type="uint8_t" name="k_uint8_t_d1_min5" default="1" min="5" />
</Knobs>""")
        with pytest.raises(InvalidRangeError):
            Schema(dom)

    def test_default_out_of_type_range_knob(self):
        dom = self.insert_xml("""
<Knobs namespace="{FE3ED49F-B173-41ED-9076-356661D46A42}">
    <Knob type="uint8_t" name="k_uint8_t_d1000" default="1000" />
</Knobs>""")
        with pytest.raises(InvalidRangeError):
            Schema(dom)

    def test_min_out_of_type_range_knob(self):
        dom = self.insert_xml("""
<Knobs namespace="{FE3ED49F-B173-41ED-9076-356661D46A42}">
    <Knob type="uint8_t" name="k_uint8_t_minn5" min="-5" />
</Knobs>""")
        with pytest.raises(InvalidRangeError):
            Schema(dom)

    def test_max_out_of_type_range_knob(self):
        dom = self.insert_xml("""
<Knobs namespace="{FE3ED49F-B173-41ED-9076-356661D46A42}">
    <Knob type="uint8_t" name="k_uint8_t_max1000" max="1000" />
</Knobs>""")
        with pytest.raises(InvalidRangeError):
            Schema(dom)

    def test_nodefault_out_of_range_knob(self):
        dom = self.insert_xml("""
<Knobs namespace="{FE3ED49F-B173-41ED-9076-356661D46A42}">
    <Knob type="uint8_t" name="k_uint8_t_min5" min="5" />
</Knobs>""")
        with pytest.raises(InvalidRangeError):
            Schema(dom)

    def test_default_out_of_range_struct(self):
        dom = self.insert_xml("""
<Structs>
<Struct name="s_invalid_t">
    <Member name="m_uint8_t" type="uint8_t" />
    <Member name="m_uint8_t_d30_max20" type="uint8_t" default="30" max="20" />
</Struct>
</Structs>""")
        with pytest.raises(InvalidRangeError):
            Schema(dom)

    def test_min_out_of_type_range_struct(self):
        dom = self.insert_xml("""
<Structs>
<Struct name="s_invalid_t">
    <Member name="m_uint8_t" type="uint8_t" />
    <Member name="m_uint8_t_minn5" type="uint8_t" min="-5" />
</Struct>
</Structs>""")
        with pytest.raises(InvalidRangeError):
            Schema(dom)

    def test_max_out_of_type_range_struct(self):
        dom = self.insert_xml("""
<Structs>
<Struct name="s_invalid_t">
    <Member name="m_uint8_t" type="uint8_t" />
    <Member name="m_uint8_t_max1000" type="uint8_t" max="1000" />
</Struct>
</Structs>""")
        with pytest.raises(InvalidRangeError):
            Schema(dom)

    def test_more_restrictive_knob_limit(self):
        # If a knob has more restrictive limits than its type
        # the more restrictive limits are used

        schema = Schema.parse(self.schemaTemplate)

        knob = schema.get_knob("k_s_limits_t_min")

        # The initial value will be None
        self.assertEqual(knob.value, None)
        # The default value should be valid
        self.assertEqual(knob.default['m_uint8_t'], 0)
        self.assertEqual(knob.default['m_uint8_t_d10'], 10)
        self.assertEqual(knob.default['m_uint8_t_d10_min5'], 10)
        self.assertEqual(knob.default['m_uint8_t_d10_max20'], 10)
        self.assertEqual(knob.default['m_e_continuous_t'], 0)
        self.assertEqual(knob.default['m_e_continuous_t_dv_1'], 1)

        # Get the a subknob and modify a single element
        # The knob has made the limit more restrictive, so the min is actually 10
        subknob = schema.get_knob("k_s_limits_t_min.m_uint8_t_d10_min5")
        subknob.value = 10
        self.assertEqual(subknob.value, 10)
        with pytest.raises(InvalidRangeError):
            subknob.value = 9  # Try setting a value out of range
        self.assertEqual(subknob.value, 10)  # Verify there was no effect

    def test_less_restrictive_knob_limit(self):
        # If a knob has less restrictive limits than its type,
        # we should fail to validate the schema
        dom = self.insert_xml("""
<Knobs namespace="{FE3ED49F-B173-41ED-9076-356661D46A42}">
    <Knob type="s_limits_t" name="k_s_limits_t_invalid" min="{0,0,0,0,,}" />
</Knobs>""")
        with pytest.raises(InvalidRangeError):
            Schema(dom)


if __name__ == '__main__':
    unittest.main()
