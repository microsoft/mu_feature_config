# @ KnobService.py
#
# Generates C header files for a firmware component to consume UEFI variables
# as configurable knobs
#
# Copyright (c) 2022, Microsoft Corporation. All rights reserved.
#
import os
import sys
import uuid
import argparse
import re
import VariableList


# Converts a type name from standard C to UEFI
def get_type_string(type_name, uefi=False):
    uefi_type = {
        "int8_t": "INT8",
        "int16_t": "INT16",
        "int32_t": "INT32",
        "int64_t": "INT64",
        "uint8_t": "UINT8",
        "uint16_t": "UINT16",
        "uint32_t": "UINT32",
        "uint64_t": "UINT64",
        "bool": "BOOLEAN",
        "float": "float",
        "double": "double",
        "size_t": "UINTN",
        "int": "INTN",
        "const": "CONST",
        "void*": "VOID *",
        "char*": "CHAR8 *",
        "config_guid_t": "EFI_GUID",
        "void": "VOID"
    }
    if uefi:
        if type_name in uefi_type:
            return uefi_type[type_name]

    return type_name


# Converts a value from standard C to UEFI
def get_value_string(value, uefi=False):
    if value == "true" and uefi:
        return "TRUE"
    elif value == "false" and uefi:
        return "FALSE"
    else:
        return value


# UEFI uses 2 spaces, stdlibc uses 4 spaces
def get_spacing_string(uefi=False, num=1):
    spaces = ""
    for i in range(0, num):
        if uefi is True:
            spaces += "  "
        else:
            spaces += "    "

    return spaces


# UEFI style uses CRLF line endings
def get_line_ending(uefi=False):
    if uefi is True:
        return "\r\n"

    return "\n"


# UEFI style uses #ifdef instead of pragma once
def get_include_once_style(name, uefi=False, header=True):
    if uefi is True:
        # convert . to _
        while True:
            match = re.search(r'\.', name)
            if not match:
                break
            name = name[:match.start()] + "_" + name[match.end():]
        if header is True:
            return "#ifndef " + name.upper() + get_line_ending(uefi) + "#define " + name.upper() + get_line_ending(uefi)
        else:
            return "#endif // " + name.upper() + get_line_ending(uefi)
    elif header is True:
        return "#pragma once" + get_line_ending(uefi)
    else:
        return get_line_ending(uefi)


# Convert std libc variable/structure/type naming conventions to UEFI naming conventions
def naming_convention_filter(value, type, uefi=False):
    if not uefi:
        return value

    if type is True:
        # types will be in format THIS_IS_THE_TYPE_NAME
        # std libc likes to append '_t' to type names, strip that for UEFI
        if value[-2:] == "_t":
            value = value[:-2]
        return value.upper()
    else:
        # fields and functions will be in format ThisIsTheName

        # if the first char is an underscore, strip it
        if value[0] == "_":
            value = value[1:]

        # capitalize first word (may be single word)
        value = value[0].upper() + value[1:]

        # remove any trailing underscore
        if value[-1] == "_":
            value = value[:-1]

        # remove the underscores and capitalize each word
        while True:
            match = re.search("_", value)
            if not match:
                break
            value = value[:match.start()] + value[match.end()].upper() + value[match.end() + 1:]

    return value


# return proper assert style for efi/non-efi builds
def get_assert_style(uefi, assert_string, msg):
    if uefi is True:
        return "STATIC_ASSERT" + assert_string + ", " + msg + ");"

    return "C_ASSERT" + assert_string + ");"


# put a SPDX header on the generated files
def get_spdx_header(header, efi_type):
    spdx = "/** @file {}".format(header)
    spdx += get_line_ending(efi_type) + get_line_ending(efi_type)
    spdx += get_spacing_string(efi_type)
    spdx += "Autogenerated configuration headers from mu_feature_config"
    spdx += get_line_ending(efi_type) + get_line_ending(efi_type)
    spdx += get_spacing_string(efi_type)
    spdx += "Copyright (c) Microsoft Corporation."
    spdx += get_line_ending(efi_type)
    spdx += get_spacing_string(efi_type)
    spdx += "SPDX-License-Identifier: BSD-2-Clause-Patent"
    spdx += get_line_ending(efi_type)
    spdx += get_line_ending(efi_type)
    spdx += "**/"
    spdx += get_line_ending(efi_type)
    spdx += get_line_ending(efi_type)
    return spdx


# Check schema for header references and extract #include directives
def get_schema_header_references(schema, efi_type):
    headerSet = set()
    for enum in schema.enums:
        if enum.headerRef != "":
            headerSet.add(enum.headerRef.strip())
    for struct in schema.structs:
        if struct.headerRef != "":
            headerSet.add(struct.headerRef.strip())
    if headerSet:
        headersSorted = sorted(headerSet)
        headers = "/* Schema-referenced headers */" + get_line_ending(efi_type)
        headers += "#ifndef STANDALONE_HEADER_NO_REFS" + get_line_ending(efi_type)
        for include in headersSorted:
            headers += '#include "{}"'.format(include)
            headers += get_line_ending(efi_type)
        headers += "#endif // STANDALONE_HEADER_NO_REFS" + get_line_ending(efi_type)
        headers += "/*--------------------------*/" + get_line_ending(efi_type)
        return headers
    return ""


# for UEFI, calculate what variable list size is for a given knob
def get_variable_list_size(knob):
    # fixed size per knob is Guid, Attributes, CRC, NameSize, DataSize
    # we have to calculate the c sizes, not the bloated python sizes
    # hence why __sizeof__() is not used here
    size = 16 + 4 + 4 + 4 + 4

    # variable size per knob is len of data and name
    # the name we convert from schema ASCII to UEFI unicode
    # And + 1 is to account for null terminator
    size += (len(knob.name) + 1) * 2
    size += knob.format.size_in_bytes()

    return size


# in UEFI builds we need to know what the size of the variable list constructed
# from this data will be. Return value in bytes
def get_conf_policy_size(schema):
    size = 0
    for knob in schema.knobs:
        size += get_variable_list_size(knob)

    return size


# write getter implementations. In stdlibc projects this is part of the data header
# for UEFI, this is separate from the data header
def write_uefi_getter_implementations(efi_type, out, schema):
    out.write("// Schema-defined knobs" + get_line_ending(efi_type))
    offset = 0
    for knob in schema.knobs:
        out.write("// {} knob".format(knob.name) + get_line_ending(efi_type))
        if knob.help != "":
            out.write("// {}".format(knob.help) + get_line_ending(efi_type))

        # Implement the cached getter function
        out.write("// Get the current value of the {} knob from supplied cache".format(
            knob.name
        ) + get_line_ending(efi_type))
        out.write("EFI_STATUS {}{}FromCache (".format(
            naming_convention_filter("config_get_", False, efi_type),
            knob.name
        ) + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type))
        out.write("{} *Knob,".format(
            get_type_string(knob.format.c_type, efi_type)
        ) + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type) + "UINT8 *Cache," + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type) + "UINT16 CacheSize" + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type) + ")" + get_line_ending(efi_type))
        out.write("{" + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type) + "EFI_STATUS Status;")
        out.write(get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type))
        # offset to data is the size of the variable list format of the knob
        # minus the data size and CRC32, which comes after the data
        offset += get_variable_list_size(knob)
        offset -= 4 + knob.format.size_in_bytes()
        out.write("CONST UINTN Offset = CACHED_POLICY_HEADER_SIZE + {};".format(
            offset
        ) + get_line_ending(efi_type))
        out.write(get_line_ending(efi_type))

        # for the next offset, move past data and CRC32
        offset += 4 + knob.format.size_in_bytes()

        out.write(get_spacing_string(efi_type))
        out.write("if ((Knob == NULL) || (Cache == NULL)) {" + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type, num=2))
        out.write("return EFI_INVALID_PARAMETER;" + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type))
        out.write("}" + get_line_ending(efi_type))
        out.write(get_line_ending(efi_type))

        out.write(get_spacing_string(efi_type))
        out.write("if (((CACHED_POLICY_HEADER *)Cache)->Signature != CACHED_POLICY_SIGNATURE) {")
        out.write(get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type, num=2))
        out.write("Status = InitConfigPolicyCache (Cache, CacheSize);" + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type, num=2))
        out.write("if (EFI_ERROR (Status)) {" + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type, num=3))
        out.write("ASSERT (FALSE);" + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type, num=3))
        out.write("return Status;" + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type, num=2))
        out.write("}" + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type))
        out.write("}" + get_line_ending(efi_type))
        out.write(get_line_ending(efi_type))

        out.write(get_spacing_string(efi_type))
        out.write("if (Offset + sizeof({}) > CacheSize) {{".format(
            get_type_string(knob.format.c_type, efi_type)
        ) + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type, num=2))
        out.write("ASSERT (FALSE);" + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type, num=2))
        out.write("return EFI_COMPROMISED_DATA;" + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type))
        out.write("}" + get_line_ending(efi_type))
        out.write(get_line_ending(efi_type))

        out.write(get_spacing_string(efi_type))
        out.write("CopyMem(Knob, Cache + Offset, sizeof ({}));".format(
            get_type_string(knob.format.c_type, efi_type)
        ) + get_line_ending(efi_type))

        out.write(get_spacing_string(efi_type))
        out.write("return EFI_SUCCESS;" + get_line_ending(efi_type))
        out.write("}" + get_line_ending(efi_type))
        out.write(get_line_ending(efi_type))

        # Implement the normal getter function, from the global cache
        out.write("// Get the current value of the {} knob from cache".format(knob.name) + get_line_ending(efi_type))
        out.write("EFI_STATUS {}{} (".format(
            naming_convention_filter("config_get_", False, efi_type),
            knob.name
        ) + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type))
        out.write("{} *Knob".format(
            get_type_string(knob.format.c_type, efi_type)
        ) + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type) + ")" + get_line_ending(efi_type))
        out.write("{" + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type))
        out.write("return {}{}FromCache (Knob, CachedPolicy, sizeof (CachedPolicy));".format(
            naming_convention_filter("config_get_", False, efi_type),
            knob.name
        ) + get_line_ending(efi_type))
        out.write("}" + get_line_ending(efi_type))
        out.write(get_line_ending(efi_type))
        pass


def generate_public_header(schema, header_path, efi_type=False, types_only=False, no_change=False):

    format_options = VariableList.StringFormatOptions()
    format_options.c_format = True
    format_options.efi_format = efi_type

    with open(header_path, 'w', newline='') as out:
        out.write(get_spdx_header(header_path, efi_type))
        out.write(get_include_once_style(header_path, uefi=efi_type, header=True))
        # UEFI uses Uefi.h instead of std libc headers
        if efi_type:
            out.write("#include <Uefi.h>" + get_line_ending(efi_type))
        else:
            out.write("#include <stdint.h>" + get_line_ending(efi_type))
            out.write("#include <stddef.h>" + get_line_ending(efi_type))
            out.write("#include <stdbool.h>" + get_line_ending(efi_type))
        out.write("// Generated Header" + get_line_ending(efi_type))
        out.write("//  Script: {}".format(sys.argv[0]) + get_line_ending(efi_type))
        out.write("//  Schema: {}".format(schema.path) + get_line_ending(efi_type))
        out.write(get_schema_header_references(schema, efi_type))
        out.write("" + get_line_ending(efi_type))
        # UEFI code uses STATIC_ASSERT, already defined in the environment
        if not efi_type:
            out.write("#ifndef C_ASSERT" + get_line_ending(efi_type))
            out.write("// Statically verify an expression" + get_line_ending(efi_type))
            out.write("#define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]" + get_line_ending(efi_type))
            out.write("#endif" + get_line_ending(efi_type))
            out.write("" + get_line_ending(efi_type))
        out.write("#pragma pack(push, 1)")
        out.write("" + get_line_ending(efi_type))
        out.write("// Schema-defined enums" + get_line_ending(efi_type))
        for enum in schema.enums:
            if enum.headerRef != "":
                out.write("#ifdef STANDALONE_HEADER_NO_REFS" + get_line_ending(efi_type))
                out.write("//The enum below is defined in {}".format(enum.headerRef) + get_line_ending(efi_type))
            if enum.help != "":
                out.write("// {}".format(enum.help) + get_line_ending(efi_type))
            out.write("typedef enum {" + get_line_ending(efi_type))
            has_negative = False
            for value in enum.values:
                if value.help != "":
                    out.write(get_spacing_string(efi_type) + "{}{} = {}, // {}".format(
                        "" if no_change else enum.name + '_',
                        value.name,
                        value.number,
                        value.help
                    ) + get_line_ending(efi_type))
                else:
                    out.write(get_spacing_string(efi_type) + "{}{} = {},".format(
                        "" if no_change else enum.name + '_',
                        value.name,
                        value.number
                    ) + get_line_ending(efi_type))

                if value.number < 0:
                    has_negative = True
            if has_negative:
                out.write(get_spacing_string(efi_type) + "_{}_PADDING = 0x7fffffff // Force packing to int size".format(
                    enum.name
                ) + get_line_ending(efi_type))
            else:
                out.write(get_spacing_string(efi_type) + "_{}_PADDING = 0xffffffff // Force packing to int size".format(
                    enum.name
                ) + get_line_ending(efi_type))
            out.write("}} {};".format(enum.name) + get_line_ending(efi_type))
            out.write("" + get_line_ending(efi_type))
            if enum.headerRef != "":
                out.write("#endif // STANDALONE_HEADER_NO_REFS" + get_line_ending(efi_type))
            assert_string = f"(sizeof({enum.name}) == sizeof({get_type_string('uint32_t', efi_type)})"
            out.write(get_assert_style(efi_type, assert_string, '"enum must be unsigned 32 bit int"'))
            out.write(get_line_ending(efi_type))
            out.write("" + get_line_ending(efi_type))
            pass

        out.write("// Schema-defined structures" + get_line_ending(efi_type))
        for struct_definition in schema.structs:
            if struct_definition.headerRef != "":
                out.write("#ifdef STANDALONE_HEADER_NO_REFS" + get_line_ending(efi_type))
                out.write("//The struct below is defined in {}".format(struct_definition.headerRef)
                          + get_line_ending(efi_type))
            if struct_definition.help != "":
                out.write("// {}".format(struct_definition.help) + get_line_ending(efi_type))
            out.write("typedef struct {" + get_line_ending(efi_type))
            for member in struct_definition.members:
                if member.help != "":
                    out.write(get_spacing_string(efi_type) + "// {}".format(member.help) + get_line_ending(efi_type))
                if member.count == 1:
                    out.write(get_spacing_string(efi_type) + "{} {};".format(
                        get_type_string(member.format.c_type, efi_type),
                        member.name) + get_line_ending(efi_type))
                else:
                    out.write(get_spacing_string(efi_type) + "{} {}[{}];".format(
                        get_type_string(member.format.c_type, efi_type),
                        member.name,
                        member.count) + get_line_ending(efi_type))

            out.write("}} {};".format(struct_definition.name) + get_line_ending(efi_type))
            out.write("" + get_line_ending(efi_type))
            if struct_definition.headerRef != "":
                out.write("#endif // STANDALONE_HEADER_NO_REFS" + get_line_ending(efi_type))
            out.write(get_assert_style(efi_type, "(sizeof({}) == {}".format(
                struct_definition.name,
                struct_definition.size_in_bytes()
            ), '"structure size must be consistent"') + get_line_ending(efi_type))
            out.write("" + get_line_ending(efi_type))
            pass
        out.write("#pragma pack(pop)" + get_line_ending(efi_type))
        if not types_only:
            out.write("" + get_line_ending(efi_type))
            out.write("// Schema-defined knobs" + get_line_ending(efi_type))
            for knob in schema.knobs:
                out.write("// {} knob".format(knob.name) + get_line_ending(efi_type))
                if knob.help != "":
                    out.write("// {}".format(knob.help) + get_line_ending(efi_type))

                out.write("" + get_line_ending(efi_type))
                for subknob in knob.subknobs:
                    if subknob.leaf:
                        define_name = subknob.name.replace('[', '_').replace(']', '_').replace('.', '__')
                        if subknob.min != subknob.format.min:
                            out.write("#define KNOB__{}__MIN {}".format(
                                define_name,
                                subknob.format.object_to_string(subknob.min, format_options))
                                + get_line_ending(efi_type))
                        if subknob.max != subknob.format.max:
                            out.write("#define KNOB__{}__MAX {}".format(
                                define_name,
                                subknob.format.object_to_string(subknob.max, format_options))
                                + get_line_ending(efi_type))

                out.write("" + get_line_ending(efi_type))
                # uefi has getters return a status and pass in a ptr
                if not efi_type:
                    out.write("// Get the current value of the {} knob".format(knob.name) + get_line_ending(efi_type))
                    out.write("{} {}{}();".format(
                        get_type_string(knob.format.c_type, efi_type),
                        naming_convention_filter("config_get_",
                                                 False,
                                                 efi_type),
                        knob.name))
                    out.write("" + get_line_ending(efi_type))
                else:
                    out.write("EFI_STATUS {}{} (".format(
                        naming_convention_filter("config_get_", False, efi_type),
                        knob.name
                    ))
                    out.write("{} *Knob);".format(
                        get_type_string(knob.format.c_type, efi_type)
                    ) + get_line_ending(efi_type))

                # no concept of setting config variables in UEFI
                if not efi_type:
                    out.write("#ifdef CONFIG_SET_VARIABLES" + get_line_ending(efi_type))
                    out.write("// Set the current value of the {} knob".format(knob.name) + get_line_ending(efi_type))
                    out.write("{} config_set_{}({} value);".format(
                        get_type_string('bool', efi_type),
                        knob.name,
                        get_type_string(knob.format.c_type, efi_type),
                    ) + get_line_ending(efi_type))
                    out.write("#endif // CONFIG_SET_VARIABLES" + get_line_ending(efi_type))
                    out.write("" + get_line_ending(efi_type))
                pass

            out.write("" + get_line_ending(efi_type))
            # UEFI uses a core header with the standard definitions
            # so we must use #defines instead of the enum
            if efi_type is False:
                out.write("typedef enum {" + get_line_ending(efi_type))
                for knob in schema.knobs:
                    out.write(get_spacing_string(efi_type) + "KNOB_{},".format(knob.name) + get_line_ending(efi_type))
                out.write(get_spacing_string(efi_type) + "KNOB_MAX" + get_line_ending(efi_type))
                out.write("}" + " {};".format(
                    naming_convention_filter("knob_t", True, efi_type)) + get_line_ending(efi_type))
            else:
                idx = 0
                for knob in schema.knobs:
                    out.write("#define KNOB_{} {}".format(
                        knob.name,
                        idx
                    ) + get_line_ending(efi_type))
                    idx += 1
                out.write("#define KNOB_MAX {}".format(idx))
            out.write("" + get_line_ending(efi_type))
            # UEFI already defines EFI_GUID and puts these
            # definitions in a standard core header
            if not efi_type:
                out.write("typedef struct {" + get_line_ending(efi_type))
                out.write("    unsigned long  Data1;" + get_line_ending(efi_type))
                out.write("    unsigned short Data2;" + get_line_ending(efi_type))
                out.write("    unsigned short Data3;" + get_line_ending(efi_type))
                out.write("    unsigned char  Data4[8];" + get_line_ending(efi_type))
                out.write("} config_guid_t;" + get_line_ending(efi_type))
                out.write("" + get_line_ending(efi_type))
                out.write("typedef struct {" + get_line_ending(efi_type))
                out.write(get_spacing_string(efi_type) + "{} {};".format(
                    get_type_string("int", efi_type),
                    naming_convention_filter("get_count", False, efi_type)
                ) + get_line_ending(efi_type))
                out.write(get_spacing_string(efi_type) + "{} {};".format(
                    get_type_string("int", efi_type),
                    naming_convention_filter("set_count", False, efi_type)
                ) + get_line_ending(efi_type))
                out.write("}" + " {};".format(
                    naming_convention_filter("knob_statistics_t", True, efi_type)
                ) + get_line_ending(efi_type))
                out.write("" + get_line_ending(efi_type))
                out.write("typedef {} ({})({} {});".format(
                    get_type_string('bool', efi_type),
                    naming_convention_filter("knob_validation_fn", True, efi_type),
                    get_type_string("const", efi_type),
                    get_type_string("void*", efi_type)
                ) + get_line_ending(efi_type))
                out.write("" + get_line_ending(efi_type))
                out.write("typedef struct {" + get_line_ending(efi_type))
                out.write(get_spacing_string(efi_type) + "{} {};".format(
                    naming_convention_filter("knob_t", True, efi_type),
                    naming_convention_filter("knob", False, efi_type)
                ) + get_line_ending(efi_type))
                out.write(get_spacing_string(efi_type) + "{} {} {};".format(
                    get_type_string("const", efi_type),
                    get_type_string("void*", efi_type),
                    naming_convention_filter("default_value_address", False, efi_type)
                ) + get_line_ending(efi_type))
                out.write(get_spacing_string(efi_type) + "{} {};".format(
                    get_type_string("void*", efi_type),
                    naming_convention_filter("cache_value_address", False, efi_type)
                ) + get_line_ending(efi_type))
                out.write(get_spacing_string(efi_type) + "{} {};".format(
                    get_type_string('size_t', efi_type),
                    naming_convention_filter("value_size", False, efi_type)
                ) + get_line_ending(efi_type))
                out.write(get_spacing_string(efi_type) + "{} {} {};".format(
                    get_type_string("const", efi_type),
                    get_type_string("char*", efi_type),
                    naming_convention_filter("name", False, efi_type)
                ) + get_line_ending(efi_type))
                out.write(get_spacing_string(efi_type) + "{} {};".format(
                    get_type_string('size_t', efi_type),
                    naming_convention_filter("name_size", False, efi_type)
                ) + get_line_ending(efi_type))
                out.write(get_spacing_string(efi_type) + "{} {};".format(
                    get_type_string("config_guid_t", efi_type),
                    naming_convention_filter("vendor_namespace", False, efi_type)
                ) + get_line_ending(efi_type))
                out.write(get_spacing_string(efi_type) + "{} {};".format(
                    get_type_string("int", efi_type),
                    naming_convention_filter("attributes", False, efi_type)
                ) + get_line_ending(efi_type))
                out.write(get_spacing_string(efi_type) + "{} {};".format(
                    naming_convention_filter("knob_statistics_t", True, efi_type),
                    naming_convention_filter("statistics", False, efi_type)
                ) + get_line_ending(efi_type))
                out.write(get_spacing_string(efi_type) + "{} {};".format(
                    naming_convention_filter("knob_validation_fn*", True, efi_type),
                    naming_convention_filter("validator", False, efi_type)
                ) + get_line_ending(efi_type))
                out.write("}" + " {};".format(
                    naming_convention_filter("knob_data_t", True, efi_type)
                ) + get_line_ending(efi_type))
                out.write("" + get_line_ending(efi_type))
                out.write("typedef struct {" + get_line_ending(efi_type))
                out.write(get_spacing_string(efi_type) + "{} {};".format(
                    naming_convention_filter("knob_t", True, efi_type),
                    naming_convention_filter("knob", False, efi_type)
                ) + get_line_ending(efi_type))
                out.write(get_spacing_string(efi_type) + "{} {};".format(
                    get_type_string("void*", efi_type),
                    naming_convention_filter("value", False, efi_type)
                ) + get_line_ending(efi_type))
                out.write("}" + " {};".format(
                    naming_convention_filter("knob_override_t", True, efi_type)
                ) + get_line_ending(efi_type))
                out.write("" + get_line_ending(efi_type))
                out.write("typedef struct {" + get_line_ending(efi_type))
                out.write(get_spacing_string(efi_type) + "{}* {};".format(
                    naming_convention_filter("knob_override_t", True, efi_type),
                    naming_convention_filter("overrides", False, efi_type)
                ) + get_line_ending(efi_type))
                out.write(get_spacing_string(efi_type) + "{} {};".format(
                    get_type_string('size_t', efi_type),
                    naming_convention_filter("override_count", False, efi_type)
                ) + get_line_ending(efi_type))
                out.write("}" + " {};".format(
                    naming_convention_filter("profile_t", True, efi_type)
                ) + get_line_ending(efi_type))
                out.write("" + get_line_ending(efi_type))
            out.write(get_include_once_style(header_path, uefi=efi_type, header=False))


def format_guid(guid):
    u = uuid.UUID(guid)

    byte_sequence = (
        u.fields[3].to_bytes(1, byteorder='big')
        + u.fields[4].to_bytes(1, byteorder='big')
        + u.fields[5].to_bytes(6, byteorder='big')
    )

    return "{{{},{},{},{{{},{},{},{},{},{},{},{}}}}}".format(
        hex(u.fields[0]),
        hex(u.fields[1]),
        hex(u.fields[2]),
        hex(byte_sequence[0]),
        hex(byte_sequence[1]),
        hex(byte_sequence[2]),
        hex(byte_sequence[3]),
        hex(byte_sequence[4]),
        hex(byte_sequence[5]),
        hex(byte_sequence[6]),
        hex(byte_sequence[7]))


def generate_cached_implementation(schema, header_path, efi_type=False, no_change=False):
    with open(header_path, 'w', newline='') as out:
        out.write(get_spdx_header(header_path, efi_type))
        out.write(get_include_once_style(header_path, uefi=efi_type, header=True))
        out.write("// The config public header must be included prior to this file" + get_line_ending(efi_type))
        out.write("// Generated Header" + get_line_ending(efi_type))
        out.write("//  Script: {}".format(sys.argv[0]) + get_line_ending(efi_type))
        out.write("//  Schema: {}".format(schema.path) + get_line_ending(efi_type))
        out.write("" + get_line_ending(efi_type))

        out.write("typedef struct {" + get_line_ending(efi_type))
        for knob in schema.knobs:
            out.write(get_spacing_string(efi_type) + "{} {};".format(
                get_type_string(knob.format.c_type, efi_type),
                knob.name) + get_line_ending(efi_type))
        out.write("}" + " {};".format(
            naming_convention_filter("knob_values_t", True, efi_type)
        ) + get_line_ending(efi_type))
        out.write("" + get_line_ending(efi_type))

        format_options = VariableList.StringFormatOptions()
        format_options.c_format = True
        format_options.efi_format = efi_type

        out.write("{} {} g{} = ".format(
            get_type_string("const", efi_type),
            naming_convention_filter("knob_values_t", True, efi_type),
            naming_convention_filter("_knob_default_values", False, efi_type)
        ) + get_line_ending(efi_type) + "{" + get_line_ending(efi_type))
        for knob in schema.knobs:
            out.write(get_spacing_string(efi_type) + ".{}={},".format(
                knob.name,
                knob.format.object_to_string(knob.default, format_options)
            ) + get_line_ending(efi_type))
        out.write("};" + get_line_ending(efi_type))

        out.write("#ifdef CONFIG_INCLUDE_CACHE" + get_line_ending(efi_type))
        out.write("{} g{} = ".format(
            naming_convention_filter("knob_values_t", True, efi_type),
            naming_convention_filter("_knob_cached_values", False, efi_type)
        ) + get_line_ending(efi_type) + "{" + get_line_ending(efi_type))
        for knob in schema.knobs:
            out.write("    .{}={},".format(
                knob.name,
                knob.format.object_to_string(knob.default, format_options)
            ) + get_line_ending(efi_type))
        out.write("};" + get_line_ending(efi_type))
        # macro use of 'knob', leave alone
        out.write("#define CONFIG_CACHE_ADDRESS(knob) (&g{}.knob)".format(
            naming_convention_filter("_knob_cached_values", False, efi_type)
        ) + get_line_ending(efi_type))
        out.write("#else // CONFIG_INCLUDE_CACHE" + get_line_ending(efi_type))
        out.write("#define CONFIG_CACHE_ADDRESS({}) (NULL)".format(
            naming_convention_filter("knob", False, efi_type)
        ) + get_line_ending(efi_type))
        out.write("#endif // CONFIG_INCLUDE_CACHE" + get_line_ending(efi_type))
        out.write("" + get_line_ending(efi_type))

        for enum in schema.enums:
            lowest_value = enum.values[0].number
            highest_value = enum.values[0].number
            for value in enum.values:
                if value.number < lowest_value:
                    lowest_value = value.number
                if value.number > highest_value:
                    highest_value = value.number

            out.write("{} {}{}({} {})".format(
                get_type_string('bool', efi_type),
                naming_convention_filter("validate_enum_value_", False, efi_type),
                enum.name,
                enum.name,
                naming_convention_filter("value", False, efi_type)) + get_line_ending(efi_type))
            out.write("{" + get_line_ending(efi_type))

            if highest_value - lowest_value > len(enum.values):
                out.write(get_spacing_string(efi_type) + "switch ({}) ".format(
                    naming_convention_filter("value", False, efi_type)
                ) + get_line_ending(efi_type) + "{" + get_line_ending(efi_type))

                for value in enum.values:
                    out.write(get_spacing_string(efi_type, 2) + "case {}{}:".format(
                        "" if no_change else enum.name + '_',
                        value.name
                    ) + get_line_ending(efi_type))
                    out.write(get_spacing_string(efi_type, 3) + "return {};".format(
                        get_value_string('true', efi_type)) + get_line_ending(efi_type))
                out.write(get_spacing_string(efi_type, 2) + "default:" + get_line_ending(efi_type))
                out.write(get_spacing_string(efi_type, 3) + "break;" + get_line_ending(efi_type))
                out.write(get_spacing_string(efi_type) + "}" + get_line_ending(efi_type))
                out.write(get_spacing_string(efi_type) + "return {};".format(
                    get_value_string('false', efi_type)
                ) + get_line_ending(efi_type))
            else:
                out.write(get_spacing_string(efi_type) + "{} {} = ({}){};".format(
                    get_type_string("int", efi_type),
                    naming_convention_filter("numeric_value", False, efi_type),
                    get_type_string("int", efi_type),
                    naming_convention_filter("value", False, efi_type)
                ) + get_line_ending(efi_type))
                out.write(get_spacing_string(efi_type) + "if ({} < {}) return {};".format(
                    naming_convention_filter("numeric_value", False, efi_type),
                    lowest_value,
                    get_value_string('false', efi_type)) + get_line_ending(efi_type))
                out.write(get_spacing_string(efi_type) + "if ({} > {}) return {};".format(
                    naming_convention_filter("numeric_value", False, efi_type),
                    highest_value,
                    get_value_string('false', efi_type)) + get_line_ending(efi_type))
                for i in range(lowest_value, highest_value):
                    found = False
                    for value in enum.values:
                        if value.number == i:
                            found = True
                            break
                    if not found:
                        out.write(get_spacing_string(efi_type) + "if ({} == {}) return {};".format(
                            naming_convention_filter("numeric_value", False, efi_type),
                            i,
                            get_value_string('false', efi_type)) + get_line_ending(efi_type))
                out.write(get_spacing_string(efi_type) + "return {};".format(
                    get_value_string('true', efi_type)
                ) + get_line_ending(efi_type))
            out.write("}" + get_line_ending(efi_type))
            out.write("" + get_line_ending(efi_type))

        out.write("" + get_line_ending(efi_type))

        out.write("{} {}({} {} {})".format(
            get_type_string('bool', efi_type),
            naming_convention_filter("validate_knob_no_constraints", False, efi_type),
            get_type_string("const", efi_type),
            get_type_string("void*", efi_type),
            naming_convention_filter("buffer", False, efi_type)
        ) + get_line_ending(efi_type))
        out.write("{" + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type) + "({}){};".format(
            get_type_string("void", efi_type),
            naming_convention_filter("buffer", False, efi_type)
        ) + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type) + "return {};".format(
            get_value_string('true', efi_type)
        ) + get_line_ending(efi_type))
        out.write("}" + get_line_ending(efi_type))
        out.write("" + get_line_ending(efi_type))
        for knob in schema.knobs:
            constraint_present = False
            for subknob in knob.subknobs:
                if subknob.leaf:
                    if isinstance(subknob.format, VariableList.EnumFormat):
                        constraint_present = True
                    else:
                        if subknob.min != subknob.format.min:
                            constraint_present = True
                        if subknob.max != subknob.format.max:
                            constraint_present = True

            if constraint_present:
                out.write("{} {}{}({} {} {})".format(
                    get_type_string('bool', efi_type),
                    naming_convention_filter("validate_knob_content_", False, efi_type),
                    knob.name,
                    get_type_string("const", efi_type),
                    get_type_string("void*", efi_type),
                    naming_convention_filter("buffer", False, efi_type)) + get_line_ending(efi_type))
                out.write("{" + get_line_ending(efi_type))
                out.write(get_spacing_string(efi_type) + "{}* {} = ({}*){};".format(
                    get_type_string(knob.format.c_type, efi_type),
                    naming_convention_filter("value", False, efi_type),
                    get_type_string(knob.format.c_type, efi_type),
                    naming_convention_filter("buffer", False, efi_type)
                ) + get_line_ending(efi_type))

                for subknob in knob.subknobs:
                    if subknob.leaf:
                        path = subknob.name[len(knob.name):]
                        define_name = subknob.name.replace('[', '_').replace(']', '_').replace('.', '__')
                        if isinstance(subknob.format, VariableList.EnumFormat):
                            if path.find('.') != -1:
                                # this is an enum inside of a struct
                                out.write(get_spacing_string(efi_type) + "if (!{}{}({}->{})) {{".format(
                                    naming_convention_filter("validate_enum_value_", False, efi_type),
                                    subknob.format.name,
                                    naming_convention_filter("value", False, efi_type),
                                    # don't take the '.'
                                    path[1:]
                                ))
                            else:
                                # this is a standalone enum knob
                                out.write(get_spacing_string(efi_type) + "if (!{}{}(*{})) {{".format(
                                    naming_convention_filter("validate_enum_value_", False, efi_type),
                                    subknob.format.name,
                                    naming_convention_filter("value", False, efi_type)
                                ))

                            out.write(get_line_ending(efi_type))
                            out.write(get_spacing_string(efi_type, num=2))
                            out.write("return {};".format(
                                get_value_string('false', efi_type))
                                + get_line_ending(efi_type)
                            )
                            out.write(get_spacing_string(efi_type) + "}" + get_line_ending(efi_type))
                        else:
                            if subknob.min != subknob.format.min:
                                out.write(get_spacing_string(efi_type))
                                out.write("if ({}{}{}{} < KNOB__{}__MIN) {{".format(
                                    "" if '.' in path else "*",
                                    naming_convention_filter("value", False, efi_type),
                                    "->" if path else "",
                                    path[1:],  # don't take the '.'
                                    define_name
                                ))
                                out.write(get_line_ending(efi_type))
                                out.write(get_spacing_string(efi_type, num=2))
                                out.write("return {};".format(
                                    get_value_string('false', efi_type))
                                    + get_line_ending(efi_type)
                                )
                                out.write(get_spacing_string(efi_type) + "}" + get_line_ending(efi_type))
                            if subknob.max != subknob.format.max:
                                out.write(get_spacing_string(efi_type))
                                out.write("if ({}{}{}{} > KNOB__{}__MAX) {{".format(
                                    "" if '.' in path else "*",
                                    naming_convention_filter("value", False, efi_type),
                                    "->" if path else "",
                                    path[1:],  # don't take the '.'
                                    define_name
                                ))
                                out.write(get_line_ending(efi_type))
                                out.write(get_spacing_string(efi_type, num=2))
                                out.write("return {};".format(
                                    get_value_string('false', efi_type))
                                    + get_line_ending(efi_type)
                                )
                                out.write(get_spacing_string(efi_type) + "}" + get_line_ending(efi_type))
                out.write(get_spacing_string(efi_type) + "return {};".format(
                    get_value_string('true', efi_type)
                ) + get_line_ending(efi_type))
                out.write("}" + get_line_ending(efi_type))
                out.write("" + get_line_ending(efi_type))
            else:
                out.write("#define {}{} {}".format(
                    naming_convention_filter("validate_knob_content_", False, efi_type),
                    knob.name,
                    naming_convention_filter("validate_knob_no_constraints", False, efi_type)
                ) + get_line_ending(efi_type))
                out.write("" + get_line_ending(efi_type))

        out.write("" + get_line_ending(efi_type))
        out.write("{} g{}[{}] = {{".format(
            naming_convention_filter("knob_data_t", True, efi_type),
            naming_convention_filter("_knob_data", False, efi_type),
            len(schema.knobs) + 1
        ) + get_line_ending(efi_type))
        for knob in schema.knobs:
            out.write(get_spacing_string(efi_type) + "{" + get_line_ending(efi_type))
            out.write(get_spacing_string(efi_type, 2) + "KNOB_{},".format(knob.name) + get_line_ending(efi_type))
            out.write(get_spacing_string(efi_type, 2) + "&g{}.{},".format(
                naming_convention_filter("_knob_default_values", False, efi_type),
                knob.name
            ) + get_line_ending(efi_type))
            out.write(get_spacing_string(efi_type, 2))
            out.write("CONFIG_CACHE_ADDRESS({}),".format(knob.name) + get_line_ending(efi_type))
            out.write(get_spacing_string(efi_type, 2))
            out.write("sizeof({}),".format(get_type_string(knob.format.c_type, efi_type)) + get_line_ending(efi_type))
            out.write(get_spacing_string(efi_type, 2))
            out.write("\"{}\",".format(knob.name) + get_line_ending(efi_type))
            out.write(get_spacing_string(efi_type, 2))
            out.write("{}, // Length of name (including NULL terminator)".format(
                len(knob.name) + 1
            ) + get_line_ending(efi_type))
            out.write(get_spacing_string(efi_type, 2))
            out.write("{}, // {}".format(format_guid(knob.namespace), knob.namespace) + get_line_ending(efi_type))
            out.write(get_spacing_string(efi_type, 2))
            out.write("{},".format(7) + get_line_ending(efi_type))
            # statistics not implemented in uefi design
            if efi_type is False:
                out.write(get_spacing_string(efi_type, 2))
                out.write("{0, 0}," + get_line_ending(efi_type))
            out.write(get_spacing_string(efi_type, 2) + "&{}{}".format(
                naming_convention_filter("validate_knob_content_", False, efi_type),
                knob.name
            ) + get_line_ending(efi_type))
            out.write(get_spacing_string(efi_type) + "}," + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type) + "{" + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type, 2) + "KNOB_MAX," + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type, 2) + "NULL," + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type, 2) + "NULL," + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type, 2) + "0," + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type, 2) + "NULL," + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type, 2) + "0," + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type, 2))
        out.write("{0,0,0,{0,0,0,0,0,0,0,0}}," + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type, 2) + "0," + get_line_ending(efi_type))
        # statistics not implemented in uefi design
        if efi_type is False:
            out.write(get_spacing_string(efi_type, 2) + "{0, 0}," + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type, 2) + "NULL")
        out.write(get_line_ending(efi_type) + get_spacing_string(efi_type) + "}" + get_line_ending(efi_type))
        out.write("};" + get_line_ending(efi_type))

        if not efi_type:
            # UEFI does not use get_knob_value
            out.write("" + get_line_ending(efi_type))
            out.write("{} {}({} {});".format(
                get_type_string("void*", efi_type),
                naming_convention_filter("get_knob_value", False, efi_type),
                naming_convention_filter("knob_t", True, efi_type),
                naming_convention_filter("knob", False, efi_type)
            ) + get_line_ending(efi_type))
            out.write("" + get_line_ending(efi_type))
            # no concept of setting config variables in UEFI
            out.write("#ifdef CONFIG_SET_VARIABLES" + get_line_ending(efi_type))
            out.write("{} set_knob_value(knob_t knob, void* value);".format(
                get_type_string('bool', efi_type)
            ) + get_line_ending(efi_type))
            out.write("#endif // CONFIG_SET_VARIABLES" + get_line_ending(efi_type))
            out.write("" + get_line_ending(efi_type))

            # UEFI utilizes a separate header for getter implementations
            out.write("// Schema-defined knobs" + get_line_ending(efi_type))
            for knob in schema.knobs:
                out.write("// {} knob".format(knob.name) + get_line_ending(efi_type))
                if knob.help != "":
                    out.write("// {}".format(knob.help) + get_line_ending(efi_type))

                out.write("// Get the current value of the {} knob".format(knob.name) + get_line_ending(efi_type))
                out.write("{} {}{}({}) {{".format(
                    get_type_string(knob.format.c_type, efi_type),
                    naming_convention_filter("config_get_", False, efi_type),
                    knob.name,
                    get_type_string("void", efi_type)
                ) + get_line_ending(efi_type))
                out.write(get_spacing_string(efi_type) + "return *(({}*){}(KNOB_{}));".format(
                    get_type_string(knob.format.c_type, efi_type),
                    naming_convention_filter("get_knob_value", False, efi_type),
                    knob.name
                ) + get_line_ending(efi_type))
                out.write("}" + get_line_ending(efi_type))
                out.write("" + get_line_ending(efi_type))
                # no concept of setting config variables in UEFI
                if not efi_type:
                    out.write("#ifdef CONFIG_SET_VARIABLES" + get_line_ending(efi_type))
                    out.write("// Set the current value of the {} knob".format(knob.name) + get_line_ending(efi_type))
                    out.write("{} config_set_{}({} value) {{".format(
                        get_type_string('bool', efi_type),
                        knob.name,
                        knob.format.c_type) + get_line_ending(efi_type))
                    out.write(get_spacing_string(efi_type) + "return set_knob_value(KNOB_{}, &value);".format(
                        knob.name
                    ) + get_line_ending(efi_type))
                    out.write("}" + get_line_ending(efi_type))
                    out.write("#endif // CONFIG_SET_VARIABLES" + get_line_ending(efi_type))
                    out.write("" + get_line_ending(efi_type))
                pass
        else:
            # give UEFI core components a knob count
            out.write(get_line_ending(efi_type))
            out.write(get_type_string("size_t", efi_type) + " g{} = KNOB_MAX;".format(
                naming_convention_filter("_num_knobs", False, efi_type))
            )
            out.write(get_line_ending(efi_type))
        out.write(get_include_once_style(header_path, uefi=efi_type, header=False))


# UEFI utilizes a third header file to hold the getter implementation
def generate_getter_implementation(schema, header_path, efi_type):
    with open(header_path, 'w', newline='') as out:
        out.write(get_spdx_header(header_path, efi_type))
        out.write(get_include_once_style(header_path, uefi=efi_type, header=True))
        out.write("// The config public header must be included prior to this file" + get_line_ending(efi_type))
        out.write("// Generated Header" + get_line_ending(efi_type))
        out.write("//  Script: {}".format(sys.argv[0]) + get_line_ending(efi_type))
        out.write("//  Schema: {}".format(schema.path) + get_line_ending(efi_type))
        out.write(get_line_ending(efi_type))

        policy_size = hex(get_conf_policy_size(schema))
        out.write("#define CACHED_POLICY_SIGNATURE    SIGNATURE_32 ('C', 'P', 'O', 'L')" + get_line_ending(efi_type))
        out.write("#define CACHED_POLICY_HEADER_SIZE  sizeof (CACHED_POLICY_HEADER)" + get_line_ending(efi_type))
        out.write(get_line_ending(efi_type))

        out.write("#define CACHED_POLICY_SIZE {}".format(
            policy_size
        ) + get_line_ending(efi_type))
        out.write(get_line_ending(efi_type))

        out.write("// Cached policy header, used to validate the cache internally" + get_line_ending(efi_type))
        out.write("#pragma pack (1)" + get_line_ending(efi_type))
        out.write(get_line_ending(efi_type))
        out.write("typedef struct {" + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type) + "UINT32 Signature;" + get_line_ending(efi_type))
        out.write("} CACHED_POLICY_HEADER;" + get_line_ending(efi_type))
        out.write(get_line_ending(efi_type))
        out.write("#pragma pack ()" + get_line_ending(efi_type))
        out.write(get_line_ending(efi_type))

        out.write("STATIC UINT8 CachedPolicy[CACHED_POLICY_SIZE + CACHED_POLICY_HEADER_SIZE];")
        out.write(get_line_ending(efi_type))
        out.write(get_assert_style(
            efi_type,
            "(CACHED_POLICY_SIZE + CACHED_POLICY_HEADER_SIZE <= MAX_UINT16",
            '"Config too large!"'))
        out.write(get_line_ending(efi_type))
        out.write(get_line_ending(efi_type))

        # InitConfigPolicyCache
        out.write("STATIC" + get_line_ending())
        out.write("EFI_STATUS" + get_line_ending(efi_type))
        out.write(naming_convention_filter("init_config_policy_cache (", False, efi_type))
        out.write(get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type) + "UINT8   *Cache," + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type) + "UINT16  CacheSize")
        out.write(get_line_ending(efi_type) + ")" + get_line_ending(efi_type) + "{")
        out.write(get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type))
        out.write("EFI_STATUS Status;" + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type))
        out.write("UINT16 ConfPolSize = CacheSize;" + get_line_ending(efi_type))
        out.write(get_line_ending(efi_type))

        out.write(get_spacing_string(efi_type))
        out.write("Status = GetPolicy (")
        out.write("PcdGetPtr (PcdConfigurationPolicyGuid), NULL,")
        out.write(" Cache + CACHED_POLICY_HEADER_SIZE, &ConfPolSize);" + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type))
        out.write("if ((EFI_ERROR (Status)) || (ConfPolSize != CACHED_POLICY_SIZE)) {" + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type, num=2) + "ASSERT (FALSE);")
        out.write(get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type, num=2))
        out.write("return Status;" + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type))
        out.write("}" + get_line_ending(efi_type))
        out.write(get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type))
        out.write("((CACHED_POLICY_HEADER*)Cache)->Signature = CACHED_POLICY_SIGNATURE;" + get_line_ending(efi_type))
        out.write(get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type))
        out.write("return Status;" + get_line_ending(efi_type))
        out.write("}" + get_line_ending(efi_type))
        out.write(get_line_ending(efi_type))

        write_uefi_getter_implementations(efi_type, out, schema)

        out.write(get_include_once_style(header_path, uefi=efi_type, header=False))


def generate_profiles(schema, profile_header_path, profile_paths, efi_type, profile_names=None, profile_ids=None):
    with open(profile_header_path, 'w', newline='') as out:
        out.write(get_spdx_header(profile_header_path, efi_type))
        out.write(get_include_once_style(profile_header_path, uefi=efi_type, header=True))
        out.write("// The config public header must be included prior to this file" + get_line_ending(efi_type))
        out.write("// Generated Header" + get_line_ending(efi_type))
        out.write("//  Script: {}".format(sys.argv[0]) + get_line_ending(efi_type))
        out.write("//  Schema: {}".format(schema.path) + get_line_ending(efi_type))
        for profile_path in profile_paths:
            out.write("//  Profile: {}".format(profile_path) + get_line_ending(efi_type))

        out.write("" + get_line_ending(efi_type))

        format_options = VariableList.StringFormatOptions()
        format_options.c_format = True
        format_options.efi_format = efi_type

        profiles = []
        for profile_path in profile_paths:
            base_name = os.path.splitext(os.path.basename(profile_path))[0]
            out.write("// Profile {}".format(base_name) + get_line_ending(efi_type))
            # Reset the schema to defaults
            for knob in schema.knobs:
                knob.value = None

            # Read the csv to override the values in the schema
            VariableList.read_csv(schema, profile_path)

            override_count = 0

            out.write("typedef struct {" + get_line_ending(efi_type))
            for knob in schema.knobs:
                if knob.value is not None:
                    override_count = override_count + 1
                    out.write(get_spacing_string(efi_type) + "{} {};".format(
                        get_type_string(knob.format.c_type, efi_type),
                        knob.name) + get_line_ending(efi_type))
            out.write("}} {}{}{};".format(
                naming_convention_filter("profile_", True, efi_type),
                base_name,
                naming_convention_filter("_data_t", True, efi_type)
            ) + get_line_ending(efi_type))

            out.write("" + get_line_ending(efi_type))
            out.write("{}{}{} {}{}{} = {{".format(
                naming_convention_filter("profile_", True, efi_type),
                base_name,
                naming_convention_filter("_data_t", True, efi_type),
                naming_convention_filter("profile_", False, efi_type),
                base_name,
                naming_convention_filter("_data", False, efi_type)
            ) + get_line_ending(efi_type))
            for knob in schema.knobs:
                if knob.value is not None:
                    out.write("    .{}={},".format(
                        knob.name,
                        knob.format.object_to_string(knob.value, format_options)) + get_line_ending(efi_type))
            out.write("};" + get_line_ending(efi_type))
            out.write("" + get_line_ending(efi_type))
            out.write("#define PROFILE_{}_OVERRIDES".format(base_name.upper()) + get_line_ending(efi_type))
            out.write("#define PROFILE_{}_OVERRIDES_COUNT {}".format(
                base_name.upper(),
                override_count
            ) + get_line_ending(efi_type))
            out.write("{} {}{}{}[PROFILE_{}_OVERRIDES_COUNT + 1] = {{".format(
                naming_convention_filter("knob_override_t", True, efi_type),
                naming_convention_filter("profile_", False, efi_type),
                base_name,
                naming_convention_filter("_overrides", False, efi_type),
                base_name.upper()
            ) + get_line_ending(efi_type))

            for knob in schema.knobs:
                if knob.value is not None:
                    out.write(get_spacing_string(efi_type) + "{" + get_line_ending(efi_type))
                    out.write(get_spacing_string(efi_type, 2) + ".{} = KNOB_{},".format(
                        naming_convention_filter("knob", False, efi_type),
                        knob.name
                    ) + get_line_ending(efi_type))
                    out.write(get_spacing_string(efi_type, 2) + ".{} = &{}{}{}.{},".format(
                        naming_convention_filter("value", False, efi_type),
                        naming_convention_filter("profile_", False, efi_type),
                        base_name,
                        naming_convention_filter("_data", False, efi_type),
                        knob.name
                    ) + get_line_ending(efi_type))
                    out.write(get_spacing_string(efi_type) + "}," + get_line_ending(efi_type))

            out.write(get_spacing_string(efi_type) + "{" + get_line_ending(efi_type))
            out.write(get_spacing_string(efi_type, 2) + ".{} = KNOB_MAX,".format(
                naming_convention_filter("knob", False, efi_type)
            ) + get_line_ending(efi_type))
            out.write(get_spacing_string(efi_type, 2) + ".{} = NULL,".format(
                naming_convention_filter("value", False, efi_type)
            ) + get_line_ending(efi_type))
            out.write(get_spacing_string(efi_type) + "}" + get_line_ending(efi_type))
            out.write("};" + get_line_ending(efi_type))
            out.write("" + get_line_ending(efi_type))

            profiles.append((base_name, override_count))
        out.write("" + get_line_ending(efi_type))
        out.write("#define PROFILE_COUNT {}".format(len(profiles)) + get_line_ending(efi_type))
        if not efi_type:
            out.write("{} {}[PROFILE_COUNT + 1] = ".format(
                naming_convention_filter("profile_t", True, efi_type),
                naming_convention_filter("profiles", False, efi_type)
            ) + get_line_ending(efi_type) + "{" + get_line_ending(efi_type))
        else:
            out.write("{} g{}[PROFILE_COUNT + 1] = ".format(
                naming_convention_filter("profile_t", True, efi_type),
                naming_convention_filter("profile_data", False, efi_type)
            ) + get_line_ending(efi_type) + "{" + get_line_ending(efi_type))
        for (profile, override_count) in profiles:
            out.write(get_spacing_string(efi_type) + "{" + get_line_ending(efi_type))
            out.write(get_spacing_string(efi_type, 2) + ".{} = {}{}{},".format(
                naming_convention_filter("overrides", False, efi_type),
                naming_convention_filter("profile_", False, efi_type),
                profile,
                naming_convention_filter("_overrides", False, efi_type)
            ) + get_line_ending(efi_type))
            out.write(get_spacing_string(efi_type, 2) + ".{} = {},".format(
                naming_convention_filter("override_count", False, efi_type),
                override_count
            ) + get_line_ending(efi_type))
            out.write(get_spacing_string(efi_type) + "}," + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type) + "{" + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type, 2) + ".{} = NULL,".format(
            naming_convention_filter("overrides", False, efi_type)
        ) + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type, 2) + ".{} = 0,".format(
            naming_convention_filter("override_count", False, efi_type)
        ) + get_line_ending(efi_type))
        out.write(get_spacing_string(efi_type) + "}" + get_line_ending(efi_type))
        out.write("};" + get_line_ending(efi_type))
        if efi_type:
            if profile_names is not None:
                names_list = profile_names.split(",")
            else:
                # If not specified, the indices will be the default profile names
                names_list = [format(i, '02x') for i in range(len(profile_paths))]

            out.write(get_line_ending(efi_type))
            out.write(get_type_string("char*", efi_type) + " g{}[PROFILE_COUNT]".format(
                naming_convention_filter("_profile_flavor_names", False, efi_type)) + " = {"
            )
            out.write(get_line_ending(efi_type))
            for profile_name in names_list:
                out.write(get_spacing_string(efi_type) + '"' + profile_name + '",' + get_line_ending(efi_type))
            out.write("};" + get_line_ending(efi_type))
            out.write(get_line_ending(efi_type))
            if profile_ids is not None:
                ids_iter = profile_ids
            else:
                # If not specified, the indices will be the default profile ids
                ids_iter = range(len(profile_paths))

            ids_list = ['0x' + format(i, '02x') for i in ids_iter]

            out.write(get_line_ending(efi_type))
            out.write(get_type_string("uint8_t", efi_type) + " g{}[PROFILE_COUNT]".format(
                naming_convention_filter("_profile_flavor_ids", False, efi_type)) + " = {"
            )
            out.write(get_line_ending(efi_type))
            for profile_id in ids_list:
                out.write(get_spacing_string(efi_type) + profile_id + ',' + get_line_ending(efi_type))
            out.write("};" + get_line_ending(efi_type))
            out.write(get_line_ending(efi_type))
            out.write(get_type_string("size_t", efi_type) + " g{} = PROFILE_COUNT;".format(
                naming_convention_filter("_num_profiles", False, efi_type))
            )
            out.write(get_line_ending(efi_type))

        out.write(get_include_once_style(profile_header_path, uefi=efi_type, header=False))


def generate_sources(schema, public_header, service_header, data_header, efi_type, options):
    generate_public_header(schema, public_header, efi_type, options.types_only, options.no_change)
    # in UEFI builds, getter implementations go to service_header and data to
    # data_header. In non-UEFI builds, both go to service_header
    # The parameters used below can be received as 'None' if a 'types_only' generation is used
    if efi_type is True:
        if service_header:
            generate_getter_implementation(schema, service_header, efi_type)
        if data_header:
            generate_cached_implementation(schema, data_header, efi_type)
    elif service_header:
        generate_cached_implementation(schema, service_header, efi_type)


def usage():
    print("Commands:\n")
    print("  generateheader[_efi] <schema.xml> <public_header.h> <service_header.h> "
          "[<data_header.h>] [<profile_header.h> <profile.csv>...]")
    print("")
    print("schema.xml       : An XML with the definition of a set of known")
    print("                   config knobs and types to interpret them\n")
    print("public_header.h  : Output header for use by config consumers\n")
    print("service_header.h : Output header for use by config provider. In UEFI builds")
    print("                   this only contains getter implementations\n")
    print("data_header.h    : Output header for UEFI builds only. This contains only")
    print("                   the data. In non-UEFI builds, service_header.h and")
    print("                   data_header.h are combined\n")
    print("profile_header.h : Output header for the profile data for consumption")
    print("                   by config providers.")
    print("profile.csv...   : n-number of profile csvs that describe the platform's")
    print("                   overridden config knobs")
    print("-pn names        : n-number of 2-character profile names that uniquely identify the")
    print("                   profiles specified in profile.csv")
    print("-pid ids         : n-number of 1-byte hexadecimal (prepend with 0x) profile id that uniquely identify the")
    print("                   profiles specified in profile.csv")
    print("-t               : Option flag to enable 'types only' outputting, forcing the generation of")
    print("                   'public_header.h' with Enum/Struct type declarations only.")
    print("                   'service_header.h' generation is skipped if this option is used.")
    print("-nc              : Option flag to enable 'no change' behavior which disables any type name modifications")
    print("                   from the input schema. All names become passthrough.")


def arg_parse():
    parser = argparse.ArgumentParser()

    parser.add_argument(
        '-pn', '--profilenames', dest='profile_names', type=str, default=None,
        help='''Specify the comma separated profile names by passing -pn <Name1,Name2> '''
             '''or --profilenames <Name1,Name2,Name3>.''')
    parser.add_argument(
        '-pid', '--profileids', dest='profile_ids', type=str, default=None,
        help='''Specify the comma separated profile ids (1-byte hexadecimal number prepend with 0x) '''
             '''by passing -pid <Id1,Id2> or --profileids <Id1,Id2,Id3>.''')
    parser.add_argument(
        '-t', '--typesonly', action='store_true', dest='types_only',
        help='''Set this option when you wish to generate only type definitions from the schema.'''
             '''Using this option will override all other parameters except <public_header.h>,'''
             '''and they can be omitted.''')
    parser.add_argument(
        '-nc', '--nochange', action='store_true', dest='no_change',
        help='''Set this option when you wish to let all schema-defined names be '''
             '''passed-through without modification.''')

    return parser.parse_known_args()


def main():
    # We should not overload the positional argument anymore given we are accepting nondeterministic number of space
    # separated profile paths... So please add the new ones here...
    known_args, left_over = arg_parse()
    sys.argv = sys.argv[:1] + left_over

    arg_num = 1
    if len(sys.argv) < 2:
        usage()
        sys.stderr.write('Must provide a command.\n')
        sys.exit(1)
        return

    if sys.argv[arg_num].lower() == "generateheader" or sys.argv[arg_num].lower() == "generateheader_efi":
        if sys.argv[arg_num].lower() == "generateheader" and len(sys.argv) < (4 if known_args.types_only else 5):
            usage()
            sys.stderr.write('Invalid number of arguments.\n')
            sys.exit(1)
            return

        if sys.argv[arg_num].lower() == "generateheader_efi" and len(sys.argv) < (4 if known_args.types_only else 6):
            usage()
            sys.stderr.write('Invalid number of arguments.\n')
            sys.exit(1)
            return

        efi_type = sys.argv[arg_num].lower() == "generateheader_efi"
        arg_num += 1

        schema_path = sys.argv[arg_num]
        arg_num += 1
        header_path = sys.argv[arg_num]
        arg_num += 1
        service_path = None
        if not known_args.types_only:
            service_path = sys.argv[arg_num]
        arg_num += 1
        data_path = None

        if efi_type is True and not known_args.types_only:
            data_path = sys.argv[arg_num]
            arg_num += 1

        # Load the schema
        schema = VariableList.Schema.load(schema_path)

        generate_sources(schema, header_path, service_path, data_path, efi_type, known_args)

        if (len(sys.argv) >= arg_num + 1) and not known_args.types_only:
            profile_header_path = sys.argv[arg_num]
            arg_num += 1
            profile_paths = sys.argv[arg_num:]

            if known_args.profile_names is not None:
                # Do some minimal sanity checks
                names = known_args.profile_names.split(",")
                if len(names) != len(profile_paths):
                    sys.stderr.write('Invalid count of profile names %d.\n' % len(names))
                    return -1

                lengths = [len(name) for name in names]
                max_length = max(lengths)
                min_length = min(lengths)

                if max_length != 2 or min_length != 2:
                    sys.stderr.write('Invalid profile names, should be 2-character for all entries.\n')
                    return -1

            if known_args.profile_ids is not None:
                # Do some minimal sanity checks
                ids = known_args.profile_ids.split(",")
                if len(ids) != len(profile_paths):
                    sys.stderr.write('Invalid count of profile ids %d.\n' % len(ids))
                    return -1

                formatted_profile_ids = []
                for id in ids:
                    if id.startswith('0x') is False:
                        sys.stderr.write('Profile id does not start with \'0x\'. \n')
                        return -1

                    profileid = int(id, 16)
                    if profileid > 0xFF:
                        sys.stderr.write('Invalid profile id value 0x%x, should be 1-byte hexadecimal number. \n'
                                         % profileid)
                        return -1
                    formatted_profile_ids.append(profileid)
            else:
                formatted_profile_ids = None

            generate_profiles(schema, profile_header_path, profile_paths, efi_type,
                              profile_names=known_args.profile_names, profile_ids=formatted_profile_ids)
        return 0


if __name__ == '__main__':
    sys.exit(main())
