/** @file s.h

  Autogenerated configuration headers from mu_feature_config

  Copyright (c) Microsoft Corporation.
  SPDX-License-Identifier: BSD-2-Clause-Patent

**/

#ifndef S_H
#define S_H
// The config public header must be included prior to this file
// Generated Header
//  Script: KnobService.py
//  Schema: ..\..\..\mu_tiano_platforms\Platforms\QemuQ35Pkg\CfgData\QemuQ35PkgCfgData.xml

STATIC CONST UINT16  CachedPolicySize = 0xe9;
STATIC CHAR8 CachedPolicy[0xe9];
STATIC BOOLEAN CachedPolicyInitialized = FALSE;
STATIC_ASSERT(0xe9 <= MAX_UINT16, "Config too large!");

STATIC
EFI_STATUS
InitConfigPolicyCache (
  VOID
)
{
  POLICY_PPI *PolPpi  = NULL;
  EFI_STATUS Status;
  UINT16 ConfPolSize = CachedPolicySize;

  Status = PeiServicesLocatePpi (
            &gPeiPolicyPpiGuid,
            0,
            NULL,
            (VOID **)&PolPpi
            );

  if (EFI_ERROR (Status)) {
    DEBUG ((DEBUG_ERROR, "%a failed to locate policy service!\n", __FUNCTION__));
    ASSERT (FALSE);
    return Status;
  }

  Status = PolPpi->GetPolicy (PcdGetPtr (PcdConfigurationPolicyGuid), NULL, CachedPolicy, &ConfPolSize);
  if ((EFI_ERROR (Status)) || (ConfPolSize != CachedPolicySize)) {
    ASSERT (FALSE);
    return Status;
  }

  CachedPolicyInitialized = TRUE;

  return Status;
}

// Schema-defined knobs
// DummyKnob1 knob
// Get the current value of the DummyKnob1 knob
EFI_STATUS ConfigGetDummyKnob1 (
  UINT32 *Knob
  )
{
  EFI_STATUS Status;
  CONST UINTN Offset = 50;

  if (Knob == NULL) {
    return EFI_INVALID_PARAMETER;
  }

  if (!CachedPolicyInitialized) {
    Status = InitConfigPolicyCache ();
    if (EFI_ERROR (Status)) {
      ASSERT (FALSE);
      return Status;
    }
  }

  if (Offset + sizeof(UINT32) > CachedPolicySize) {
    ASSERT (FALSE);
    return EFI_COMPROMISED_DATA;
  }

  CopyMem(Knob, CachedPolicy + Offset, sizeof (UINT32));
  return EFI_SUCCESS;
}

// DummyKnob2 knob
// Get the current value of the DummyKnob2 knob
EFI_STATUS ConfigGetDummyKnob2 (
  UINT32 *Knob
  )
{
  EFI_STATUS Status;
  CONST UINTN Offset = 108;

  if (Knob == NULL) {
    return EFI_INVALID_PARAMETER;
  }

  if (!CachedPolicyInitialized) {
    Status = InitConfigPolicyCache ();
    if (EFI_ERROR (Status)) {
      ASSERT (FALSE);
      return Status;
    }
  }

  if (Offset + sizeof(UINT32) > CachedPolicySize) {
    ASSERT (FALSE);
    return EFI_COMPROMISED_DATA;
  }

  CopyMem(Knob, CachedPolicy + Offset, sizeof (UINT32));
  return EFI_SUCCESS;
}

// PowerOnPort0 knob
// Get the current value of the PowerOnPort0 knob
EFI_STATUS ConfigGetPowerOnPort0 (
  BOOLEAN *Knob
  )
{
  EFI_STATUS Status;
  CONST UINTN Offset = 170;

  if (Knob == NULL) {
    return EFI_INVALID_PARAMETER;
  }

  if (!CachedPolicyInitialized) {
    Status = InitConfigPolicyCache ();
    if (EFI_ERROR (Status)) {
      ASSERT (FALSE);
      return Status;
    }
  }

  if (Offset + sizeof(BOOLEAN) > CachedPolicySize) {
    ASSERT (FALSE);
    return EFI_COMPROMISED_DATA;
  }

  CopyMem(Knob, CachedPolicy + Offset, sizeof (BOOLEAN));
  return EFI_SUCCESS;
}

// DummyKnob3 knob
// Get the current value of the DummyKnob3 knob
EFI_STATUS ConfigGetDummyKnob3 (
  UINT32 *Knob
  )
{
  EFI_STATUS Status;
  CONST UINTN Offset = 225;

  if (Knob == NULL) {
    return EFI_INVALID_PARAMETER;
  }

  if (!CachedPolicyInitialized) {
    Status = InitConfigPolicyCache ();
    if (EFI_ERROR (Status)) {
      ASSERT (FALSE);
      return Status;
    }
  }

  if (Offset + sizeof(UINT32) > CachedPolicySize) {
    ASSERT (FALSE);
    return EFI_COMPROMISED_DATA;
  }

  CopyMem(Knob, CachedPolicy + Offset, sizeof (UINT32));
  return EFI_SUCCESS;
}

#endif // S_H
